== What is an SQL Attack?

Because of the ubiquity of SQL databases, SQL Injection is one of the most common types of attack on the internet.

Prevalence: Medium

Exploitability: Easy

Impact: Devastating

You can use a SQL attack to bypass authentication, manipulate data, extract sensitive information, inject malicious code and even bring down the entire database.

SQL injection attacks are common. Major companies such as Yahoo and Sony have had their applications compromised. Even security firms have fallen foul of this attack.

Testing for SQL injection:

https://www.owasp.org/index.php/Testing_for_SQL_Injection_(OTG-INPVAL-005)[OWASP]
https://www.acunetix.com/blog/articles/exploiting-sql-injection-example/[Good Example]

== Protection against SQL attacks

=== Sanitizing Inputs

Sanitizing inputs is a good practice for all applicants. Attackers usually start with an input of `' or 1=1--` to see if an attack is possible, which looks pretty suspicious and will quickly identify an attacker.

Developers should always make an effort to reject inputs that look suspicious out of hand, while taking care not to accidentally punish legitimate users. For instance, your application may clean parameters supplied in GET and POST requests the following ways:

* Check that supplied fields like email addresses match a regular expression.
* Ensure that numeric or alphanumeric fields do not contain symbol characters.
* Reject (or strip) out whitespace and new line characters where they are not appropriate.

Whatever front-end framework you're using, there's usually JavaScript libraries that will help you do this.

NOTE: Client-side validation (i.e. in JavaScript) is useful for giving the user immediate feedback when filling a form, but is no defence against a serious attacker who will use scripts, rather than the browser itself. Server-side validation is also needed.

=== Parameterized Statements/Queries

Programming languages talk to SQL databases using database drivers. A driver allows an application to construct and run SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure that the parameters (i.e. inputs) passed into SQL statements are treated in a safe manner.

Secure way of running a SQL query using a parameterized statement:

[source,java]
----
 // Define which user we want to find.
 String email = "user@email.com";

 // Connect to the database.
 Connection conn = DriverManager.getConnection(URL, USER, PASS);
 Statement stmt = conn.createStatement();

 // Construct the SQL statement we want to run, specifying the parameter.
 String sql = "SELECT * FROM users WHERE email = ?"

 // Run the query, passing the 'email' parameter value...
 ResultSet results = stmt.executeQuery(sql, email);

 while (results.next()) { +
      // ...do something with the data returned. +
 }
----

An insecure way would be to construct the SQL query outside of the driver commands:

[source,java]
----
 // Bad, bad news! Don't construct the query with string concatenation.
 String sql = "SELECT * FROM users WHERE email = '" + email + "'";

 // I have a bad feeling about this...
 ResultSet results = stmt.executeQuery(sql);

 while (results.next()){
      // we got hacked
 }
----

The key difference is the data being passed to the `executeQuery(...)` method. In the first case, the parameterized string and the parameters are passed to the database separately, which allows the driver to correctly interpret them. In the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to maliciously crafted parameters.

Some users use ORM (Object Relational Mapping) to pass data to the database. This is still vulnerable if you still write SQL statements by concatenating strings.

=== Principle of Least Privilege

Applications should ensure that each process or software component can access and affect only the resources it needs. It is rarely necessary for applications to change the structure of the database at run-time - typically tables are created, dropped, and modified during release windows, with temporarily elevated permissions. Therefore it is good practice to reduce permissions of applications at runtime, so it can at most __edit__ data, but not change table structures.

In a SQL database, this measn making sure your production accounts can only execute DML statements, not DDL statements.

Many processes can be permissioned to perform data edits only through stored procedures, or to execute with read-only permissions.

=== Password hashing

Don't store passwords in plain-text. Store them in strong, one-way salted hashes.

=== Third party Authentication.

Outsource authentication to Facebook, Twitter or Google through OAuth.

=== Escaping inputs

If you are unable to use parameterized statements or a library that writes SQL for you, the next best approach is to ensure proper escaping of special string characters in input parameters.

Injection attacks often rely on the attacker being able to craft an input that will prematurely close the argument string in which they appear in the SQL statement. (This is why you you will often see `'` or `"` characters in attempted SQL injection attacks.)

Programming languages have standard ways to describe strings containing quotes within them – SQL is no different in this respect. Typically, doubling up the quote character – replacing `'` with `''` – means “treat this quote as part of the string, not the end of the string”.

Escaping symbol characters is a simple way to protect against most SQL injection attacks, and many languages have standard functions to achieve this. There are a couple of drawbacks to this approach, however:

NOTE: You need to be very careful to escape characters everywhere in your codebase where an SQL statement is constructed.

Not all injection attacks rely on abuse of quote characters. For example, when an numeric ID is expected in a SQL statement, quote characters are not required. The following code is still vulnerable to injection attacks, no matter how much you play around with quote characters:

[source,python]
----
 def current_user(id)
    User.where("id = " + id)
 end
----